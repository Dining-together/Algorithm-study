# 정렬

## 정의

- 데이터를 특정한 기준에 따라서 순서대로 나열하는 것

## 대표 정렬 알고리즘

### 선택 정렬

- 가장 작은 데이터를 선택해 이미 교체된 부분을 제외하고 나서의 맨 앞의 원소와 교체
- 여러 개의 데이터가 무작위로 있을 때, 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정
- 매번 가장 작은 것을 선택한다는 의미에서 선택 정렬
- O(N^2)의 시간 복잡도 -> 다른 알고리즘보다 비효율적

```python
for i in range(len(array)):
    min_index = i
    for j in range(i+1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
        array[i], array[min_index] = array[min_index], array[i]
```

### 삽입 정렬

- 앞 원소와 차례대로 비교하여 삽입할 위치를 결정 (자신의 위치 -> 앞 순서로 비교해나감)
- 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다. 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하므로, 두 번째 데이터부터 시작한다.
- 특정한 데이터를 적절한 위치에 삽입한다는 의미에서 삽입 정렬
- 필요할 때만 위치를 바꾸므로 데이터가 거의 정렬되어 있을 때 훨씬 효율적
- 이중 반복문으로 O(N^2)의 시간 복잡도를 가지지만, 거의 정렬되어 있는 최선의 경우에는 O(N)

```python
for i in range(1, len(array)):
   for j in range(i, 0, -1):
       if array[j] < arrayp[j-1]:
           array[j], array[j-1] = array[j-1], array[j]
       else:
           break
```

### 퀵 정렬

- 선택, 삽입 정렬 알고리즘보다 많이 사용되는 알고리즘으로, 병합 정렬 알고리즘과 비슷한 삐른 속도의 정렬 알고리즘
- 기준(피벗)을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작
- 피벗을 어떻게 설정할 것인지 미리 명시해야 하는데, 여러 리스트 분할 방식 중 호어 분할 방식은 리스트에서 첫 번째 데이터를 피벗으로 정하는 방식
- 피벗을 설정한 뒤에 왼쪽에서부터 피벗보다 큰 데이트롤 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾은 다음 서로 교환한다. 반복하다가 왼쪽에서 찾는 값과 오른쪽에서 찾는 값의 위치가 엇갈리면 작은 데이터와 피벗의 위치를 교환한다. 이동한 피벗의 왼쪽 리스트는 피벗보다 모두 작은 값들이고 오른쪽 리스트는 큰 값들로 분할된다. 왼쪽 리스트와 오른쪽 리스트에서도 각각 피벗을 설정하여 동일한 방법으로 정렬을 수행한다.
- 재귀를 통해 구현하는데, 현재 리스트의 개수가 1개일 경우가 종료 조건.
- O(NlogN)의 평균 시간 복잡도, 최악의 경우엔 O(N^2)

```python
def quick_sort(array):
   if len(array) <= 1:
       break
   pivot = array[0]
   tail = array[1:]
   left_side = [x for x in tail if x <= pivot]
   right_side = [x for x in tail if x > pivot]

   return quick_sort(left_side) + [pivot] + quick_sort(right_side)
```

### 계수 정렬

- 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용 가능한 알고리즘으로 매우 빠름.
- 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용 가능
- 모든 범위를 담을 수 있는 크기의 리스트를 선언한다. 그 다음 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다. 리스트에는 각 데이터가 몇 번 등장했는지 그 횟수가 기록된다. 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 인덱스를 출력하면 정렬된 결과
- 데이터의 개수가 N, 데이터 중 최대값이 K일 때, 최악의 경우에도 O(N+K)의 시간 복잡도를 보장
- 현존하는 정렬 알고리즘 중 기수 정렬(radix sort)과 더불어 가장 빠르다.
- 공간 복잡도는 비효율적이므로 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합.

```python
count = [0] * (max(array)+1)

for i in range(len(array)):
   count[array[i]] += 1

for i in range(len(count)):
   for j in range(count[i]):
       print(i, end=' ')
```

## 파이썬의 정렬 라이브러리

- sorted()는 정렬된 결과를 출력, 반환되는 결과는 리스트 자료형
- sort()는 내부 원소를 바로 정렬, key 매개변수가 정렬 기준으로 함수나 람다 사용
- 병합 정렬과 삽입 정렬의 아이디어를 더한 하이브리드 방식의 정렬 알고리즘으로 구현되었으며, 최악의 경우에도 O(NlogN)의 시간 복잡도를 보장
- 정렬 라이브러리로 풀 수 있는 문제, 정렬 알고리즘의 원리에 대해서 물어보는 문제, 더 빠른 정렬이 필요한 문제(계수정렬 등의 다른 알고리즘, 또는 기존 알고리즘을 개선)의 유형으로 나눌 수 있다.
