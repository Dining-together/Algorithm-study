# 탐색

## 정의

- 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정

## 기초 자료구조

- 자료구조: 데이터를 표현하고 관리하고 처리하기 위한 구조
- 스택과 큐의 기초 개념으로 핵심적인 두 함수: push(데이터 삽입), pop(데이터 삭제)
- 오버플로(Overflow): 특정한 자료구조가 수용할 수 있는 데이터의 크기가 이미 가득 찬 상태에서 삽입연산을 수행할 때 발생. 즉, 저장 공간을 벗어나 데이터가 넘쳐흐를 때 발생
- 언더플로(Underflow): 데이터가 전혀 들어 있지 않은 상태에서 삭제 연산을 수행할 때 발생

### 스택

- 선입후출 또는 후입선출
- 박스 쌓기에 비유

```python
stack = []
stack.append(1)
stack.pop()
print(stack)
print(stack[::-1]) # 최상단 원소부터 출력
```

### 큐

- 선입선출
- 대기 줄에 비유

```python
from collections import deque

queue = deque()
queue.append(1)
queue.popleft()

print(queue) # 먼저 들어온 원소부터 출력
queue.reverse()
print(queue) # 나중에 들어온 원소부터 출력
```

### 재귀

- 자기 자신을 다시 호출하는 함수
- 종료 조건을 반드시 명시해야 한다.
- 내부적으로 스택 자료구조와 동일

```python
def factorial_recursive(n):
    if n<=1:
        return 1
    return n * factorial_recursive(n-1)

print(factorial_recursive(100))
```

### 그래프

- 노드(node, 또는 정점, vertex)와 간선(edge)으로 이루어진다.
- 두 노드가 간선으로 연결되어 있다 = 두 노드가 인접하다(adjacent)
- 그래프 탐색이란, 하나의 노드를 시작으로 다수의 노드를 방문하는 것

#### 인접 행렬(Adjacency Matrix)

- 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식
- 연결이 되어 있지 않은 노드끼리는 무한의 비용이라고 작성

```python
INF = 999999999

graph=[
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]

print(graph)
```

#### 인접 리스트(Adjacency List)

- 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장

```python
graph =[[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장 (노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장 (노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장 (노드, 거리)
graph[2].append((0, 5))

print(graph)
```

#### 두 방식 비교

- 인접 행렬 방식은 모든 관계를 저장하므로 노드의 개수가 많을수록, 메모리가 불필요하게 낭비된다.
- 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.
- 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는 지에 대한 정보를 얻는 속도가 느리다. 연결된 데이터를 하나씩 확인해야 하기 때문이다.

## 대표 탐색 알고리즘

### DFS (깊이 우선 탐색 알고리즘)

- 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘
- 스택 자료구조를 이용하며, 구체적인 동작 과정은 다음과 같다.
- O(N)의 시간복잡도

```
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다. 방문 처리는 스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것을 의미한다. 이로써 각 노드를 한 번씩만 처리할 수 있다.
2. 스택의 최상단 노드에 방문하지 않은 인접 보드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 여러 개 있을 경우 일반적으로 번호가 낮은 순서부터 처리한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
```

```python
# 각 노드가 연결된 정보를 리스트 자료형으로 표현 (2차원 리스트)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

def dfs(graph, v, visited):
    visited[v] = True
    print(v, end=" ")
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

dfs(graph, 1, visited)
# 출력 결과: 1 2 7 6 8 3 4 5
```

### BFS (너비 우선 탐색 알고리즘)

- 가까운 노드부터 탐색
- 큐 자료구조 이용
- 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어, 가까운 노드부터 탐색을 진행하게 된다. 구체적인 동작 과정은 다음과 같다. 마찬가지로 인접한 노드가 여러 개 있을 때, 숫자가 낙은 노드부터 먼저 큐에 삽입.
- O(N)의 시간복잡도, BFS가 DFS보다 수행시간이 좋은 편

```
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
```

```python
from collections import deque

def bfs(graph, start, visited):
    queque = deque([start])
    visited[start] = True
    while queue:
        v = queue.pop()
        print(v, end=" ")
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

bfs(graph, 1, visited)
# 출력 결과: 1 2 3 8 7 4 5 6
```
